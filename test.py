# Keystream generated using "./q1.bin 00101101 00101100 744", the initial state has been found using the last bits of the candidate key for the first block of 40 bits with "./q3.bin".

# Binary to ASCII conversion performed using https://mothereff.in/binary-ascii

# len(plaintext from agree) = 672

keystream = "001101001101101000100111011011000011101001001000001011000111000000110111101000000010010100111111110001100010101010000100001100110000011111011101111110101001011010101100111001001100100010111000100011110010111100001010001101011111001111011001010111010110111001101001101101000100111011011000011101001001000001011000111000000110111101000000010010100111111110001100010101010000100001100110000011111011101111110101001011010101100111001001100100010111000100011110010111100001010001101011111001111011001010111010110111001101001101101000100111011011000011101001001000001011000111000000110111101000000010010100111111110001100010101010000100001100110000011111011101111110101001011010010111000100011110010111100001010001101011111001111011001010111010110111"

agree = "0100000101000111010100100100010101000101"
agree_encrypted = "0111010110011101011101010010100101111111" # With the first 40 bits of the keystream

# I searched agree_encrypted in the ciphertext and started decrypting from there on with the rest of the keystream
# For the previous part of the ciphertext I just cut the first 72 bit (length of the ciphertext - what we can already decrypt) and appended them to the end of the ciphertext variable, extended the keystream to reach the full period and copied the bits coming before the first bits in the keystream variable and decrypted the rest (not very efficient but simple).

ciphertext = "011101011001110101110101001010010111111101101000011110110011100101100011111010000000010101101000100011100110101111010000000100110101111010010010101011111011011011100100101001011001111011111101101011110111101101000101000101011010000010011000000001000100001001001001111101100001101110001100010101001101100101111000101101110010011000001100000001100101111111001000000100000100111000100011010000011111111111010101011110010001011011101001110001010011100101011011011111100101000000101110101001101110011011110010111111001000101000100111110010001110001011001001011100101111100010000111100101101101010010110100101010110101011110001010010000111000110101000110010101111010001100001110000101010110011111010011110010100011101010110111101000111111101010010111"

def xor_str(s1, s2, n = 0):
	# assert(len(s1) == len(s2))
	if n == 0:
		n = min(len(s1), len(s2))
	result = ""
	for i in range(n):
		result += str((int(s1[i]) ^ int(s2[i])))
	return result

# ciphertext_blocks = [ciphertext[i:i+8] for i in range(0, len(ciphertext), 8)]

# print xor_str(agree, keystream, 40) # Encrypt AGREE to use it later
print xor_str(keystream, ciphertext)

# The result in ASCII is: "AGREE WITH WHAT YOU HAVE TO SAY, BUT I WILL DEFEND TO THE DEATH YOUR RIGHT TO SAY ITI DO NOT "